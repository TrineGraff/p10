library(ggplot2)
library(gridExtra)
library(foreach)
library(tidyverse)
rawdata <- read.csv("/Users/LouiseNygaardChristensen/Desktop/P10/R/data/FRED_MD/current.csv", sep = ",",
header = TRUE)
head(rawdata)
tail(rawdata)
data <- rawdata[-1, -1]
n = nrow(data)
p = ncol(data)
data_matrix = matrix(nrow = n, ncol = p)
for(j in 1:p){
for(i in 1:n){
if(is.na(data[i,j]))
data_matrix[i,j] = 1
else
data_matrix[i,j] = 0
}
}
plot(c(1), xlim = c(1,139), ylim = c(1, 708), col = "white", ylab = 'Tidsobservationer', xlab = "Forklarende variable")
for(i in 1:n){
for(j in 1:p){
if(data_matrix[i,j] == 1)
points(j,i, col = "black", pch = 20, cex = 0.1)
}
}
abline(h = 13, col = "red", lty = "dashed")
abline(h = 706, col = "red", lty = "dashed")
LocateNAs = function(data){
for(i in 1:ncol(data)){
number = length(which(is.na(data[ ,i])))
cat("Kolonne =", i, "\t Antal NAs =", number, "\n")
}
}
LocateNAs(data)
fjernet_var <- rawdata[c(2:14, 705,709), c(1, 59, 61, 96, 124, 129)]
non.na_data <- rawdata[-c(2:14, 705:709), -c(1, 59, 61, 96, 124, 129)]
LocateNAs(non.na_data)
transxf <- function(x, tcode) {
if(tcode == 1) x
else if(tcode == 2) diff(x)
else if(tcode == 3) diff(x, 2)
else if(tcode == 4) log(x)
else if(tcode == 5) diff(log(x))
else if(tcode == 6) diff(log(x), 2)
else if(tcode == 7) diff(x[-1] / x[-length(x)] - 1)
}
nas <- c(0, 1, 2, 0, 1, 2, 2)
tcodes <- as.numeric(non.na_data[1, ])
transf_data <- foreach(i = 1:ncol(non.na_data), .combine = cbind) %do% {
if(nas[tcodes[i]] != 0) {
c(rep(NA, nas[tcodes[i]]), transxf(non.na_data[-1, i], tcodes[i]))
}
else transxf(non.na_data[-1, i], tcodes[i])
}
colnames(transf_data) <- names(non.na_data)
transformed_data <- data.frame(transf_data)
dato <- as.Date(rawdata$sasdate[-c(1:14, 705:709)], format = "%m/%d/%Y")
dato <- as.Date(rawdata$sasdate[-c(1:14, 705:709)], format = "%m/%d/%Y")
# ikke-stationær
data_nons <- data.frame(dato,
rawdata[-c(1:14, 705:709), -c(1, 59, 61, 96, 124, 129)])
rpi_nons <- ggplot(data_nons, aes(dato, RPI)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("RPI")
unrate_nons <- ggplot(data_nons, aes(dato, UNRATE)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("UNRATE")
m1sl_nons <- ggplot(data_nons, aes(dato, M1SL)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("M1SL")
m2sl_nons <- ggplot(data_nons, aes(dato, M2SL)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("M2SL")
fedfunds_nons <- ggplot(data_nons, aes(dato, FEDFUNDS)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("FEDFUNDS")
tb3ms_nons <- ggplot(data_nons, aes(dato, TB3MS)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("TB3MS")
gs5_nons <- ggplot(data_nons, aes(dato, GS5)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("GS5")
exjpusx_nons <- ggplot(data_nons, aes(dato, EXJPUSx)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("EXJPUSx")
cpiaucsl_nons <- ggplot(data_nons, aes(dato, CPIAUCSL)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("CPIAUCSL")
sp500_nons <- ggplot(data_nons, aes(dato, S.P.500)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("S.P.500")
grid.arrange(rpi_nons, unrate_nons, m1sl_nons, m2sl_nons, fedfunds_nons,
tb3ms_nons, gs5_nons, exjpusx_nons, cpiaucsl_nons, sp500_nons, ncol=2)
# stationær
data_s <- data.frame(dato, transformed_data)
data_s
write.csv(data_s, file = "transformed_data.csv")
rpi_s <- ggplot(data_s, aes(dato, RPI)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("RPI")
unrate_s <- ggplot(data_s, aes(dato, UNRATE)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("UNRATE")
m1sl_s <- ggplot(data_s, aes(dato, M1SL)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("M1SL")
m2sl_s <- ggplot(data_s, aes(dato, M2SL)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("M2SL")
fedfunds_s <- ggplot(data_s, aes(dato, FEDFUNDS)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("FEDFUNDS")
tb3ms_s <- ggplot(data_s, aes(dato, TB3MS)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("TB3MS")
gs5_s <- ggplot(data_s, aes(dato, GS5)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("GS5")
exjpusx_s <- ggplot(data_s, aes(dato, EXJPUSx)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("EXJPUSx")
cpiaucsl_s <- ggplot(data_s, aes(dato, CPIAUCSL)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("CPIAUCSL")
sp500_s <- ggplot(data_s, aes(dato, S.P.500)) + geom_line() +
labs(x = " ", y = "?") + ggtitle("S.P.500")
grid.arrange(rpi_s, unrate_s, m1sl_s, m2sl_s, fedfunds_s,
tb3ms_s, gs5_s, exjpusx_s, cpiaucsl_s, sp500_s, ncol=2)
install.packages(vars)
install.packages("vars")
library(vars)
transformed_data <- read.csv("/Users/LouiseNygaardChristensen/Desktop/P10/R/data/transformed_data.csv")
transformed_data
head(transformed_data)
tail(transformed_data)
# opdeler data i træningsmængde (2/3) og testmængde (1/3)
train <- transformed_data[1:600, -c(1, 2)]
test <- transformed_data[601:690, -c(1, 2)]
RMSE <- function(error){
sqrt(mean(error^2))
}
fit <- princomp(train, cor=TRUE)
train
# opdeler data i træningsmængde (2/3) og testmængde (1/3)
train <- transformed_data[3:600, -c(1, 2)]
train
# opdeler data i træningsmængde (2/3) og testmængde (1/3)
train <- transformed_data[2:600, -c(1, 2)]
train
# opdeler data i træningsmængde (2/3) og testmængde (1/3)
train <- transformed_data[3:600, -c(1, 2)]
test <- transformed_data[601:690, -c(1, 2)]
fit <- princomp(train, cor=TRUE)
fit
summary(fit) # print variance accounted for
loadings(fit) # pc loadings
plot(fit,type="lines") # scree plot
fit$scores # the principal components
biplot(fit)
# Varimax Rotated Principal Components
# retaining 5 components
library(psych)
fit <- principal(mydata, nfactors=5, rotate="varimax")
fit <- principal(train, nfactors=5, rotate="varimax")
fit # print results
# Maximum Likelihood Factor Analysis
# entering raw data and extracting 3 factors,
# with varimax rotation
fit <- factanal(train, 3, rotation="varimax")
# Maximum Likelihood Factor Analysis
# entering raw data and extracting 3 factors,
# with varimax rotation
fit <- factanal(train, 3, rotation="varimax")
print(fit, digits=2, cutoff=.3, sort=TRUE)
# plot factor 1 by factor 2
load <- fit$loadings[,1:2]
plot(load,type="n") # set up plot
text(load,labels=names(mydata),cex=.7) # add variable names
# Principal Axis Factor Analysis
library(psych)
fit <- factor.pa(train, nfactors=3, rotation="varimax")
fit <- factor.pa(train, nfactors=3, rotation="varimax")
fit <- factor.pa(train, nfactors=4, rotation="varimax")
fit <- factor.pa(train, nfactors=5, rotation="varimax")
fit <- factor.pa(train, nfactors=100, rotation="varimax")
fit <- factor.pa(train, nfactors=3, rotation="varimax")
# Determine Number of Factors to Extract
library(nFactors)
# Determine Number of Factors to Extract
install.packages("nFactors")
# Determine Number of Factors to Extract
#install.packages("nFactors")
library(nFactors)
ev <- eigen(cor(mydata)) # get eigenvalues
ev <- eigen(cor(train)) # get eigenvalues
# Determine Number of Factors to Extract
#install.packages("nFactors")
library(nFactors)
ev <- eigen(cor(train)) # get eigenvalues
ap <- parallel(subject=nrow(train),var=ncol(train),
rep=100,cent=.05)
nS <- nScree(x=ev$values, aparallel=ap$eigen$qevpea)
plotnScree(nS)
install.packages("gglasso")
library(gglasso)
library(gglasso)
transformed_data <- read.csv("/Users/LouiseNygaardChristensen/Desktop/P10/R/data/transformed_data.csv")
head(transformed_data)
tail(transformed_data)
# opdeler data i træningsmængde (2/3) og testmængde (1/3)
train <- transformed_data[3:600, -c(1, 2)] # 3 da vi undgår na
test <- transformed_data[601:690, -c(1, 2)]
RMSE <- function(error){
sqrt(mean(error^2))
}
respons <- train$RPI
n <- length(respons)
model.matrix <- as.matrix(train)
model.matrix
data <- transformed_data
group1 <- data.frame(data$RPI, data$W875RX1, data$INDPRO, data$IPFPNSS, data$IPFINAL, data$IPCONGD,
data$IPDCONGD, data$IPNCONGD, data$IPBUSEQ, data$IPMAT, data$IPDMAT, data$IPNMAT,
data$IPMANSICS, data$IPB51222S, data$IPFUELS, data$CUMFNS)
group2 <- data.frame(data$HWI, data$HWIURATIO, data$CLF16OV, data$CE16OV, data$UNRATE, data$UEMPMEAN,
data$UEMPLT5, data$UEMP5TO14, data$UEMP15OV, data$UEMP15T26, data$UEMP27OV, data$CLAIMSx,
data$PAYEMS, data$USGOOD, data$CES1021000001, data$USCONS, data$MANEMP, data$DMANEMP,
data$NDMANEMP, data$SRVPRD, data$USTPU, data$USWTRADE, data$USTRADE, data$USFIRE,
data$USGOVT, data$CES0600000007, data$AWOTMAN, data$AWHMAN, data$CES0600000008, data$CES2000000008,
data$CES3000000008)
group3 <- data.frame(data$HOUST, data$HOUSTNE, data$HOUSTMW, data$HOUSTS, data$HOUSTW, data$PERMIT,
data$PERMITNE, data$PERMITMW, data$PERMITS, data$PERMITW)
group4 <- data.frame(data$DPCERA3M086SBEA, data$CMRMTSPLx, data$RETAILx, data$AMDMNOx,
data$AMDMUOx, data$BUSINVx, data$ISRATIOx)
group5 <- data.frame(data$M1SL, data$M2SL, data$M2REAL, data$AMBSL, data$TOTRESNS, data$NONBORRES,
data$BUSLOANS, data$REALLN, data$NONREVSL, data$CONSPI, data$MZMSL, data$DTCOLNVHFNM,
data$DTCTHFNM, data$INVEST)
group6 <- data.frame(data$FEDFUNDS, data$CP3Mx, data$TB3MS, data$TB6MS, data$GS1, data$GS5,
data$GS10, data$AAA, data$BAA, data$COMPAPFFx, data$TB3SMFFM, data$TB6SMFFM,
data$T1YFFM, data$T5YFFM, data$T10YFFM, data$AAAFFM, data$BAAFFM, data$EXSZUSx,
data$EXJPUSx, data$EXUSUKx, data$EXCAUSx)
group7 <- data.frame(data$WPSFD49207, data$WPSFD49502, data$WPSID61, data$WPSID62, data$OILPRICEx, data$PPICMM,
data$CPIAUCSL, data$CPIAPPSL, data$CPITRNSL, data$CPIMEDSL, data$CUSR0000SAC, data$CUSR0000SAD,
data$CUSR0000SAS, data$CPIULFSL, data$CUSR0000SA0L2, data$CUSR0000SA0L5,data$PCEPI, data$DDURRG3M086SBEA,
data$DNDGRG3M086SBEA, data$DSERRG3M086SBEA)
group8 <- data.frame(data$S.P.500, data$S.P..indust, data$S.P.div.yield, data$S.P.PE.ratio)
fit <- gglasso(model.matrix, respons, group = group1)
model.matrix
model.matrix$
train
model.matrix$
train
train
install.packages("grplasso")
library(gglasso)
library(grplasso)
transformed_data
cbind(1,1)
cbind(1,1, c(1, 2))
crow(1,1, c(1, 2))
rbind(1,1, c(1, 2))
rbind(1,1, rep(1, 6))
c(1,1)
?rbind
c(1, 1, rep(2, 6), 4)
model.matrix$
grp <- c(1, 1, 4, 4, 4, rep(1, 15))
model.matrix$
grp <- c(1, 1, 4, 4, 4, rep(1, 15))
grp
model.matrix$
grp <- c(1, 1, 4, 4, 4, rep(1, 15))
model.matrix$
grp <- c(1, 1, 4, 4, 4, rep(1, 15))
grp
grp <- c(1, 1, 4, 4, 4, rep(1, 15))
grp
model.matrix$
grp <- c(1, 1, 4, 4, 4, rep(1, 14), rep(2, 28), rep(3, 10), rep(4, 4),
rep(5, 10), rep(8, 4), rep(6, 21), rep(7, 20), rep(2, 3), rep(5, 4))
grp <- c(1, 1, 4, 4, 4, rep(1, 14), rep(2, 28), rep(3, 10), rep(4, 4),
rep(5, 10), rep(8, 4), rep(6, 21), rep(7, 20), rep(2, 3), rep(5, 4))
fit <- gglasso(model.matrix, respons, group = grp)
#install.packages("gglasso")
library(gglasso)
#install.packages("grplasso")
library(grplasso)
transformed_data <- read.csv("/Users/LouiseNygaardChristensen/Desktop/P10/R/data/transformed_data.csv")
head(transformed_data)
tail(transformed_data)
# opdeler data i træningsmængde (2/3) og testmængde (1/3)
train <- transformed_data[3:600, -c(1, 2)] # 3 da vi undgår na
test <- transformed_data[601:690, -c(1, 2)]
# RPI som responsvariabel
respons <- train$RPI
n <- length(respons)
model.matrix <- as.matrix(train)
grp <- c(1, 1, 4, 4, 4, rep(1, 14), rep(2, 28), rep(3, 10), rep(4, 4),
rep(5, 10), rep(8, 4), rep(6, 21), rep(7, 20), rep(2, 3), rep(5, 4))
fit <- gglasso(model.matrix, respons, group = grp)
fit
coef.mat=fit$beta
coef <- fit$beta
coef
View(fit)
cv.fit <- cv.gglasso(model.matrix, respons, group = grp)
cv.fit
plot(cv.fit)
lambda <- cv.fit$lambda
lambda
lambda <- cv.fit$lambda.min
lambda
coef <- coef(cv.fit)
coef
y.hat <- train %*% coef
train
y.hat <- model.matrix %*% coef
y.hat <- model.matrix %*% coef
coef
y.hat <- model.matrix %*% coef
cv.fit <- cv.gglasso(model.matrix, respons, group = grp, nfolds = 10)
lambda <- cv.fit$lambda.1se
coef <- coef.gglasso(fit, s = lambda)
(coef <- coef.gglasso(fit, s = lambda))
fit <- grpreg(model.matrix, respons, group = grp, penalty = "grLasso")
library(grpreg)
install.packages("grpreg")
#install.packages("grpreg")
library(grpreg)
fit <- grpreg(model.matrix, respons, group = grp, penalty = "grLasso")
fit$beta
fit <- grpreg(model.matrix, respons, group = grp, penalty="grMCP") # The former involves an MCP penalty being applied to an L2-norm of each group.
plot(fit, main = "Group MCP")
fit <- grpreg(model.matrix, respons, group = grp, penalty="grSCAD")
plot(fit, main = "Group SCAD")
fit <- grpreg(model.matrix, respons, group = grp, penalty="gel") #Group exponential lasso
plot(fit, main ="gel")
fit <- grpreg(model.matrix, respons, group = grp, penalty="cMCP") # a hierarchical penalty which places an outer MCP penalty on a sum of inner MCP penalties for each group
plot(fit, main ="cMCP")
dev.off()
res <- select(fit, criterion = "AIC")
res$lambda
par(mfrow=c(1,2))
cvfit <- cv.grpreg(model.matrix, respons, group = grp, seed =12345)
# lambda based on minimum cv error rule
cvfit$lambda.min
cvfit$cve
cvfit$cvse
plot(cvfit)
summary(cvfit)
coef(cvfit) ## Beta at minimum CVE
cvfit <- cv.grpreg(model.matrix, respons, group = grp,penalty = "grSCAD")
plot(cvfit)
summary(cvfit)
coef(cvfit) ## Beta at minimum CVE
dev.off()
library(SGL) # sparse group lasso, similar as elastic net.
install.packages("SGL")
library(SGL) # sparse group lasso, similar as elastic net.
data <- list(x=model.matrix, y=respons)

n.obs = length(y)
X_lag = matrix(nrow = n.obs, ncol = p)
for(j in 1:p){
for (i in 1:n.obs){
X_lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(X_lag), crossprod(X_lag, y))
sigma2.hat = mean((y- X_lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC_vektor[p] = BIC
}
print(BIC_vektor)
}
X_lag(y, 10)
X_lag = function(x, p.max){
BIC_vektor = c(NA)
for(p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
X_lag = matrix(nrow = n.obs, ncol = p)
for(j in 1:p){
for (i in 1:n.obs){
X_lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(X_lag), crossprod(X_lag, y))
sigma2.hat = mean((y- X_lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC_vektor[p] = BIC
}
print(BIC_vektor)
print(which.min(BIC_vektor))
}
X_lag(y, 10)
X_lag = function(x, p.max){
BIC_vektor = c(NA)
for(p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
X_lag = matrix(nrow = n.obs, ncol = p)
for(j in 1:p){
for (i in 1:n.obs){
X_lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(X_lag), crossprod(X_lag, y))
sigma2.hat = mean((y- X_lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC_vektor[p] = BIC
}
print(BIC_vektor)
print(which.min(BIC_vektor))
}
X_lag(y, 24)
X_lag = function(x, p.max){
BIC_vektor = c(NA)
for(p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
X_lag = matrix(nrow = n.obs, ncol = p)
for(j in 1:p){
for (i in 1:n.obs){
X_lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(X_lag), crossprod(X_lag, y))
sigma2.hat = mean((y- X_lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC_vektor[p] = BIC
}
print(BIC_vektor)
print(which.min(BIC_vektor))
}
X_lag(y, 12)
?solve
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC_vektor[p] = BIC
}
x.lag = function(x, p.max){
BIC_vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC_vektor[p] = BIC
}
print(BIC_vektor)
print(which.min(BIC_vektor))
}
x.lag = function(x, p.max){
BIC_vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC_vektor[p] = BIC
}
print(BIC_vektor)
print(which.min(BIC_vektor))
}
x.lag(y, 12)
x.lag = function(x, p.max){
BIC_vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC_vektor[p] = BIC
}
list(BIC_vektor)
print(which.min(BIC_vektor))
}
x.lag(y, 12)
x.lag = function(x, p.max){
BIC_vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC_vektor[p] = BIC
}
print(list(
p = p,
BIC = BIC_vektor))
}
x.lag(y, 12)
x.lag = function(x, p.max){
BIC.vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
}
print(list(
p = p,
BIC = BIC.vektor,
beta = beta.hat))
}
x.lag(y, 12)
x.lag = function(x, p.max){
BIC.vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
}
print(list(
p = p,
BIC = BIC.vektor,
beta = beta.hat),
sigma2hat = sigma2.hat)
}
x.lag(y, 12)
x.lag = function(x, p.max){
BIC.vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
}
print(list(
p = p,
BIC = BIC.vektor,
beta = beta.hat,
sigma2hat = sigma2.hat))
}
x.lag(y, 12)
x.lag = function(x, p.max){
BIC.vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
}
print(list(
p = p,
BIC = BIC.vektor,
beta = beta.hat))
}
x.lag(y, 12)
fit = x.lag(y, 12)
which.min(fit$beta)
which.min(fit$BIC)
x.lag = function(x, p.max){
BIC.vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
}
print(list(which.min(BIC)))
}
fit = x.lag(y, 12)
fit
which.min(fit$BIC)
x.lag = function(x, p.max){
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
}
print(list(BIC = BIC.vektor)
}
fit = x.lag(y, 12)
which.min(fit$BIC)
x.lag = function(x, p.max){
BIC.vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
}
print(list(BIC = BIC.vektor))
}
fit = x.lag(y, 12)
which.min(fit$BIC)
x.lag = function(x, p.max){
BIC.vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
print(beta.hat)
}
print(list(BIC = BIC.vektor))
}
fit = x.lag(y, 12)
x.lag = function(x, p.max){
BIC.vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
}
print(which.min(BIC.vektor))
}
fit = x.lag(y, 12)
beta.hat = function(x, p) {
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
list.out <- list("beta.hat" = beta.hat )
}
beta.hat(y, 11)
beta.hat = function(x, p) {
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
list.out <- list("beta.hat" = beta.hat )
}
beta.hat(y, 11)
beta.hat = function(x, p) {
y = x[(p + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
list.out <- list("beta.hat" = beta.hat )
}
beta.hat(y, 11)
beta.hat = function(x, p) {
y = x[(p + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
print(list("beta.hat" = beta.hat ))
}
beta.hat(y, 11)
x.lag = function(x, p.max){
BIC.vektor = c(NA)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
print(beta.hat)
sigma2.hat = mean((y- x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
}
print(which.min(BIC.vektor))
}
x.lag(y, 12)
beta.hat(y, 11)
forecast = function(y, x, idx = idx, lambda) {
fc = c(NA)
for(k in 0:length(y[-c(1:idx)]) - 1) {
y_res = y[1:(idx + k)] #y bliver opdateret med den observerede værdi for hvert k
x_kov = x[1:(idx + k), ]
lambda = rep(lambda, length(y_res))
print(lambda)
#beta_hat = lambda %*% diag(length(y_res))
}
}
lambda.min = read.csv("results/ridge_lambda.csv")
?glmnet
library(glmnet)
?glmnet
library(gglasso)
?gglasso
source("/Users/trinegraff/Desktop/Projekt/R/data/setup_data.R")
library(lars)
library(ggplot2)
library(elasticnet)
library(broom)
drops = c("UNRATE")
x = data_train[ , !(colnames(data_train) %in% drops)]
y = data$UNRATE[1:idx]
y = data[,"UNRATE"[1:idx]]
y = data_train[, "UNRATE"]
y
y
parm = function(x) {
(sum(x != 0))
}
set.seed(109)
# lasso -------------------------------------------------------------------
lars_cv = cv.lars(x, y, type = "lasso", intercept = FALSE, normalize = FALSE, trace = TRUE)
lars_ = lars(x, y, type = "lasso")
min <- min(lars_cv$cv)
idmin = match(min, lars_cv$cv)
l1_min = lars_cv$index[idmin]
se = (lars_cv$cv + lars_cv$cv.error)[idmin]
idse = lars_cv$cv <= se #større eller lig med en standard afvigelse
l1_1se = max(lars_cv$index[idse], na.rm = TRUE)
match(lars_cv$index, l1_1se)
data.frame(
lambda = c("min", "1se"),
vaedi = c(l1_min, l1_1se),
error = c(lars_cv$cv[idmin], lars_cv$cv[37]),
p = c(parm(coef(lars_, s = l1_min, mode = "fraction")), parm(coef(lars_, s = l1_1se, mode = "fraction")) )
#fraction fordi vi har L1 norm af vektoren (se plot)
)
b_hat = coef(lars_, s = l1_min, mode = "fraction")
idx_hat = which(b_hat != 0)
b_hat[idx_hat]
lars_ = lars(x, y, type = "lasso")
lars_
?lars
setwd("~/Desktop/Projekt/R/unrate")
source("data_unrate.R")
source("package.R")
source("data_unrate.R")
source("parm.R")
source("shrinkage_metoder/res_plot.R")
source("shrinkage_metoder/adj.r.2.R")
set.seed(1)
lasso_fit = glmnet(x_train, y_train, family = "gaussian", alpha = 1, intercept = FALSE, standardize=FALSE)
lasso_cv = cv.glmnet(x_train, y_train, intercept = FALSE, family = "gaussian", alpha = 1, standardize=FALSE)
data.frame(
lambda = c("min", "1se"),
lambda_val = c(log(lasso_cv$lambda.min), log(lasso_cv$lambda.1se)),
error = with(lasso_cv, c(cvm[which(lambda == lasso_cv$lambda.min)], cvm[which(lambda == lasso_cv$lambda.1se)])),
p = apply(coef(lasso_fit, s = c(lasso_cv$lambda.min, lasso_cv$lambda.1se)), 2, parm)
)
x_train
dim(x)

lambda = c("min", "1se"),
vaedi = c(l1_min, l1_1se),
error = c(lars_cv$cv[idmin], lars_cv$cv[37]),
p = c(parm(coef(lars_, s = l1_min,, mode = "fraction")), parm(coef(lars_, s = l1_1se,, mode = "fraction")) )
#fraction fordi vi har L1 norm af vektoren (se plot)
)
data.frame(
lambda = c("min", "1se"),
vaedi = c(l1_min, l1_1se),
error = c(lars_cv$cv[idmin], lars_cv$cv[37]),
p = c(parm(coef(lars_, s = l1_min, mode = "fraction")), parm(coef(lars_, s = l1_1se, mode = "fraction")) )
#fraction fordi vi har L1 norm af vektoren (se plot)
)
l1_1se
lars_cv$index
match(lars_cv$index, l1_1se)
data.frame(
lambda = c("min", "1se"),
vaedi = c(l1_min, l1_1se),
error = c(lars_cv$cv[idmin], lars_cv$cv[37]),
p = c(parm(coef(lars_, s = l1_min, mode = "fraction")), parm(coef(lars_, s = l1_1se, mode = "fraction")) )
#fraction fordi vi har L1 norm af vektoren (se plot)
)
gglasso
library(gglasso)
?gglasso()
?cv.glmnet
library(glmnet)
?cv.glmnet
?glmnet
# lasso -------------------------------------------------------------------
lasso_fit = glmnet(x, y, family = "gaussian", alpha = 1, intercept = FALSE, standardize=FALSE)
drops = c("UNRATE")
x = data_train[ , !(colnames(data_train) %in% drops)]
y = data$UNRATE[1:idx]
parm = function(x) {
(sum(x != 0))
}
# lasso -------------------------------------------------------------------
lasso_fit = glmnet(x, y, family = "gaussian", alpha = 1, intercept = FALSE, standardize=FALSE)
source("/Users/trinegraff/Desktop/Projekt/R/data/setup_data.R")
drops = c("UNRATE")
x = data_train[ , !(colnames(data_train) %in% drops)]
y = data$UNRATE[1:idx]
set.seed(1)
# lasso -------------------------------------------------------------------
lasso_fit = glmnet(x, y, family = "gaussian", alpha = 1, intercept = FALSE, standardize=FALSE)
lasso_cv = cv.glmnet(x, y, intercept = FALSE, family = "gaussian", alpha = 1, standardize=FALSE)
idmin = match(lasso_cv$lambda.min, lasso_cv$lambda)
lambda_1se = max(lasso_cv$lambda[idmin], na.rm = TRUE)
data.frame(
lambda = c("min", "1se"),
lambda_val = c(lasso_cv$lambda.min, lasso_cv$lambda.1se),
error = with(lasso_cv, c(cvm[which(lambda == lasso_cv$lambda.min)], cvm[which(lambda == lasso_cv$lambda.1se)])),
p = apply(coef(lasso_fit, s = c(lasso_cv$lambda.min, lasso_cv$lambda.1se)), 2, parm)
)
lasso_cv = cv.glmnet(x, y, intercept = FALSE, family = "gaussian", alpha = 1, standardize=FALSE)
idmin = match(lasso_cv$lambda.min, lasso_cv$lambda)
lambda_1se = max(lasso_cv$lambda[idmin], na.rm = TRUE)
data.frame(
lambda = c("min", "1se"),
lambda_val = c(lasso_cv$lambda.min, lasso_cv$lambda.1se),
error = with(lasso_cv, c(cvm[which(lambda == lasso_cv$lambda.min)], cvm[which(lambda == lasso_cv$lambda.1se)])),
p = apply(coef(lasso_fit, s = c(lasso_cv$lambda.min, lasso_cv$lambda.1se)), 2, parm)
)
source("/Users/trinegraff/Desktop/Projekt/R/data/setup_data.R")
library(tidyverse)
library(glmnet)
library(gglasso)
library(ggplot2)
library(gridExtra)
set.seed(1)
drops = c("UNRATE")
x = data_train[ , !(colnames(data_train) %in% drops)]
y = data$UNRATE[1:idx]
lasso_fit = glmnet(x, y, family = "gaussian", alpha = 1, intercept = FALSE, standardize=FALSE)
lasso_cv = cv.glmnet(x, y, intercept = FALSE, family = "gaussian", alpha = 1, standardize=FALSE)
ridge_fit = glmnet(x, y, family = "gaussian", alpha = 0, intercept = FALSE, standardize=FALSE)
ridge_cv = cv.glmnet(x, y, intercept = FALSE, family = "gaussian", alpha = 0, standardize=FALSE)
alpha.grid = seq(0.1, 0.9, length = 10)
for (i in alpha.grid) {
assign(paste("fit",i , sep=""), cv.glmnet(x, y, alpha=i,family="gaussian", standardize=FALSE))
}
grp <- c(1, 1, rep(4, 3), rep(1, 14), rep(2, 27), rep(3, 10), rep(4, 4),
rep(5, 10), rep(8, 4), rep(6, 21), rep(7, 20), rep(2, 3), rep(5, 4))
gglasso_cv <- cv.gglasso(x, y, group = grp, nfold = 10, intercept = FALSE, standardize=FALSE)
gglasso_fit = gglasso(x, y, group = grp, intercept = FALSE, standardize=FALSE)
?cv.gglasso
?gglasso
gglasso_cv <- cv.gglasso(x, y, group = grp, nfold = 10, intercept = FALSE, loss = "ls" )
gglasso_cv
gglasso_fit = gglasso(x, y, group = grp, intercept = FALSE, loss = "ls")
setwd("~/Desktop/Projekt/R/unrate/script")
source("/Users/trinegraff/Desktop/Projekt/R/unrate/script/script.R")
# orden p -----------------------------------------------------------------
#Vi bestemmer orden af vores træningsmængde
source("../data/setup_data.R")
# orden p -----------------------------------------------------------------
#Vi bestemmer orden af vores træningsmængde
source("data_unrate.R")
setwd("~/Desktop/Projekt/R/unrate")
# orden p -----------------------------------------------------------------
#Vi bestemmer orden af vores træningsmængde
source("data_unrate.R")
x.lag = function(x, p.max){
BIC.vektor = rep(NA, p.max)
for (p in 1:p.max){
y = x[(p.max + 1):length(x)]
n.obs = length(y)
x.lag = matrix(nrow = n.obs, ncol = p)
for (j in 1:p){
for (i in 1:n.obs){
x.lag[i,j] = x[p+i-j]
}
}
beta.hat = solve(crossprod(x.lag), crossprod(x.lag, y))
sigma2.hat = mean((y - x.lag %*% beta.hat)^2)
BIC = log(sigma2.hat) + (p * log(n.obs)/n.obs)
BIC.vektor[p] = BIC
}
print(which.min(BIC.vektor))
#print(BIC.vektor)
}
test = x.lag(y_train, 12)
source("../data_unrate.R")
source("../data_unrate.R")
setwd("~/")
setwd("~/Desktop/Projekt/R/unrate/forecasts")
setwd("~/Desktop/Projekt/R/unrate/script")
setwd("~/Desktop/Projekt/R/unrate")
source("../data_unrate.R")
source("data_unrate.R")
library(Metrics)
library(ggplot2)
library(gridExtra)
library(grid)
# Forecast - AR -----------------------------------------------------------
forecast = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)])) {
y = data[(p + 1):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast(y, 11, idx)
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)])) {
y = data[(p + 1):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
length(fit)
length(fit$fc)
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)]) -1) {
y = data[(p + 1):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
length(fit$fc)
fit = forecast_ar(y, 11, idx)
plot(fit, type = "l", col = "red")
plot(fit$fc, type = "l", col = "red")
plot(fit$fc, type = "l", col = "red", xlim = c(0, 140), ylim = c(-0.5, 0.5))
)
par(new= TRUE)
plot(y,type = "l", xlim = c(0, 140), ylim = c(-0.5, 0.5) )
plot(y_test,type = "l", xlim = c(0, 140), ylim = c(-0.5, 0.5) )
plot(fit$fc, type = "l", col = "red", xlim = c(0, 140), ylim = c(-0.5, 0.5))
par(new= TRUE)
plot(y_test,type = "l", xlim = c(0, 140), ylim = c(-0.5, 0.5) )
y[length(y[1:idx])]
match(y[length(y[1:idx])], y)
1:idx
y
length((data:1:idx) -3 +1)
length((data:1:idx)) -3 +1)
length((data(1:idx)) -3 +1
)
length(data(1:idx))
length(y(1:idx))
length(y[1:idx])
length(y[1:idx] -3 +1)
length(y[1:idx]) -3 +1)
length(y[1:idx]) -3 +1
y[553:550]
y[552:550]
dato = c(as.character(test_dato))
df = data.frame(date = as.Date(dato), fc = fit$fc, y =  y[-c(1:idx)])
dato = c(as.character(test_dato))
df = data.frame(date = as.Date(dato), fc = fit$fc, y =  y[-c(1:idx)])
df
ggplot(df, aes(x = date ))  +
geom_line(aes(y = y, colour = "Arbejdsløshed")) +
geom_line(aes(y = fc, colour = "AR(1)")) +
ylab("Rate") + xlab("Dato") +
scale_colour_manual(values = c("red", "gray")) +
theme(legend.title=element_blank()) +
ggtitle("One-step-ahead forecast")
ggplot(df, aes(x = date ))  +
geom_line(aes(y = y, colour = "Arbejdsløshed")) +
geom_line(aes(y = fc, colour = "AR(11)")) +
ylab("Rate") + xlab("Dato") +
scale_colour_manual(values = c("red", "gray")) +
theme(legend.title=element_blank()) +
ggtitle("One-step-ahead forecast")
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)]) -1) {
y = data[(p + k):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
plot(fit$fc, type = "l", col = "red", xlim = c(0,140), ylim = c(-0.6, 0.6))
plot(fit$fc, type = "l", col = "red", xlim = c(0,140), ylim = c(-0.4, 0.4))
par(new = TRUE)
plot(y_test, type = "l", xlim = c(0,140), ylim = c(-0.4, 0.4))
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)]) -1) {
y = data[(p + k):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
print(length(y))
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)]) -1) {
y = data[(p + 1):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
print(length(y))
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
idx
552-11
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)]) -1) {
y = data[(p + 1):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
print((y))
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)]) -1) {
y = data[(p + k):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
print((y))
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
plot(y)
acf2(y)
acf2AR(y)
acf(y)
pacf(y)
acf(y)
pacf(y)
y
plot(y, type = "l")
plot(data_raw$UNRATE, type = "l")
plot(y, type = "l")
plot(data_raw$UNRATE, type = "l")
y = scale(data[, "UNRATE"], scale = FALSE, center = TRUE)
plot(y, type = "l")
data_raw
x
source("../data/setup_data.R")
source("../data/setup_data.R")
drops = c("UNRATE")
x = scale(data[ , !(colnames(data) %in% drops)])
y = scale(data[, "UNRATE"], scale = FALSE, center = TRUE)
x_train = x[1:idx,]
y_train = y[1:idx]
x_test = x[-c(1:idx),]
y_test = y[-c(1:idx)]
plot(y)
plot(y, type = "l")
plot(y, type = "l", xlim = c(0,140), ylim = c(-0.5, 0.5))
plot(y, type = "l", xlim = c(0,140), ylim = c(-0.5, 0.5))
y
plot(y, type = "l", xlim = c(0,900), ylim = c(-0.5, 0.5))
plot(y, type = "l", xlim = c(0,700), ylim = c(-0.5, 0.5))
plot(data_raw$UNRATE, col = "red", xlim = c(0,700), ylim = c(-0.5, 0.5) )
plot(y, type = "l", xlim = c(0,700), ylim = c(-0.5, 0.5))
par(new = TRUE)
plot(data_raw$UNRATE, type = "l", col = "red", xlim = c(0,700), ylim = c(-0.5, 0.5) )
mean(y)
mean(data_raw$UNRATE)
identical(y, data_raw$UNRATE)
y
(data_raw$UNRATE)
scale(data_raw$UNRATE, center = TRUE)
h = scale(data_raw$UNRATE, center = TRUE)
identical(h, y)
identical(as.vector(h), as.vector(y))
h = scale(data_raw$UNRATE, center = TRUE, scale = FALSE)
h
identical(as.vector(h), as.vector(y))
source("../data/setup_data.R")
drops = c("UNRATE")
x = scale(data[ , !(colnames(data) %in% drops)], scale = TRUE, center = TRUE)
y = scale(data[, "UNRATE"], scale = FALSE, center = TRUE)
x_train = x[1:idx,]
y_train = y[1:idx]
x_test = x[-c(1:idx),]
y_test = y[-c(1:idx)]
x
y
x
library(tseries)
adf.test(y)
?adf.test
diff(y)
plot(diff(y))
plot(diff(y), type = "l")
adf.test(diff(y))
adf.test(diff(log(y)))
adf.test(diff(log(y)))
adf.test(log(diff((y)))
)
diff(y, 2)
adf.test(diff(y, 2))
adf.test(diff(y, 10))
?adf.test
FRED_MD <- read.csv("../data/FRED_MD/current.csv", sep = ",", header = TRUE)
date <- as.Date(FRED_MD[-1, 1], format = "%m/%d/%Y")
rawdata <- FRED_MD[-1, -1]
rawdata$UNRATE
plot(rawdata$UNRATE, type = "l")
plot(diff(rawdata$UNRATE), type = "l")
plot(diff(rawdata$UNRATE, 2), type = "l")
res = scale(fit$fc - y[-c(1:idx)])
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)]) -1) {
y = data[(p + k):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
print((y))
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)]) -1) {
y = data[(p + k):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
plot(fit$fc, type = "l", col = "red", xlim = c(0,140), ylim = c(-0.4, 0.4))
par(new = TRUE)
plot(y, type = "l", xlim = c(0,700), ylim = c(-0.5, 0.5))
plot(y_test, type = "l", xlim = c(0,700), ylim = c(-0.5, 0.5))
plot(fit$fc, type = "l", col = "red", xlim = c(0,140), ylim = c(-0.4, 0.4))
par(new = TRUE)
plot(y_test, type = "l", xlim = c(0,140), ylim = c(-0.5, 0.5))
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)]) - 1) {
y = data[(p + k):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
print(n)
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
# Forecast - AR -----------------------------------------------------------
forecast_ar = function(data, p, idx = idx) {
fc = c(NA)
for(k in 0:length(data[-c(1:idx)]) - 1) {
y = data[(p + k):(length(data[1:idx]) + k)] #y bliver opdateret med den sande værdi for hvert k
n = length(y)
print(y)
x_lag = matrix(nrow = n, ncol = p)
for (j in 1:p){
for (i in 1:n){
x_lag[i,j] = data[p+i-j]
}
}
beta_hat = solve(crossprod(x_lag), crossprod(x_lag, y))
fc[k+1] = data[(length(data[1:idx]) + k):(length(data[1:idx]) + k - p + 1)] %*% beta_hat
}
print(list("fc" = fc))
}
fit = forecast_ar(y, 11, idx)
dato = c(as.character(test_dato))
df = data.frame(date = as.Date(dato), fc = fit$fc, y =  y[-c(1:idx)])
ggplot(df, aes(x = date ))  +
geom_line(aes(y = y, colour = "Arbejdsløshed")) +
geom_line(aes(y = fc, colour = "AR(11)")) +
ylab("Rate") + xlab("Dato") +
scale_colour_manual(values = c("red", "gray")) +
theme(legend.title=element_blank()) +
ggtitle("One-step-ahead forecast")
